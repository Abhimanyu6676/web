{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport io from \"socket.io-client\";\nimport { reportError, clearError } from \"./error-overlay-handler\";\nimport normalizePagePath from \"./normalize-page-path\";\nvar socket = null;\nvar inFlightGetPageDataPromiseCache = {};\nvar staticQueryData = {};\nvar pageQueryData = {};\nexport var getStaticQueryData = function getStaticQueryData() {\n  return staticQueryData;\n};\nexport var getPageQueryData = function getPageQueryData() {\n  return pageQueryData;\n};\nexport default function socketIo() {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!socket) {\n      try {\n        socket = io({\n          transports: [process.env.GATSBY_SOCKET_IO_DEFAULT_TRANSPORT]\n        });\n        socket.on(\"reconnect_attempt\", function () {\n          socket.io.opts.transports = [\"polling\", \"websocket\"];\n        });\n\n        var didDataChange = function didDataChange(msg, queryData) {\n          var id = msg.type === \"staticQueryResult\" ? msg.payload.id : normalizePagePath(msg.payload.id);\n          return !(id in queryData) || JSON.stringify(msg.payload.result) !== JSON.stringify(queryData[id]);\n        };\n\n        socket.on(\"connect\", function () {\n          Object.keys(inFlightGetPageDataPromiseCache).forEach(function (pathname) {\n            socket.emit(\"getDataForPath\", pathname);\n          });\n        });\n        socket.on(\"message\", function (msg) {\n          if (msg.type === \"staticQueryResult\") {\n            if (didDataChange(msg, staticQueryData)) {\n              staticQueryData = _objectSpread(_objectSpread({}, staticQueryData), {}, _defineProperty({}, msg.payload.id, msg.payload.result));\n            }\n          } else if (msg.type === \"pageQueryResult\") {\n            if (didDataChange(msg, pageQueryData)) {\n              pageQueryData = _objectSpread(_objectSpread({}, pageQueryData), {}, _defineProperty({}, normalizePagePath(msg.payload.id), msg.payload.result));\n            }\n          } else if (msg.type === \"overlayError\") {\n            if (msg.payload.message) {\n              reportError(msg.payload.id, msg.payload.message);\n            } else {\n              clearError(msg.payload.id);\n            }\n          }\n\n          if (msg.type && msg.payload) {\n            ___emitter.emit(msg.type, msg.payload);\n          }\n        });\n        socket.on(\"disconnect\", function () {\n          console.warn(\"[socket.io] Disconnected from dev server.\");\n        });\n      } catch (err) {\n        console.error(\"Could not connect to socket.io on dev server.\");\n      }\n    }\n\n    return socket;\n  } else {\n    return null;\n  }\n}\n\nfunction getPageData(pathname) {\n  pathname = normalizePagePath(pathname);\n\n  if (inFlightGetPageDataPromiseCache[pathname]) {\n    return inFlightGetPageDataPromiseCache[pathname];\n  } else {\n    inFlightGetPageDataPromiseCache[pathname] = new Promise(function (resolve) {\n      if (pageQueryData[pathname]) {\n        delete inFlightGetPageDataPromiseCache[pathname];\n        resolve(pageQueryData[pathname]);\n      } else {\n        var onPageDataCallback = function onPageDataCallback(msg) {\n          if (msg.type === \"pageQueryResult\" && normalizePagePath(msg.payload.id) === pathname) {\n            socket.off(\"message\", onPageDataCallback);\n            delete inFlightGetPageDataPromiseCache[pathname];\n            resolve(pageQueryData[pathname]);\n          }\n        };\n\n        socket.on(\"message\", onPageDataCallback);\n        socket.emit(\"getDataForPath\", pathname);\n      }\n    });\n  }\n\n  return inFlightGetPageDataPromiseCache[pathname];\n}\n\nfunction registerPath(path) {\n  socket.emit(\"registerPath\", path);\n}\n\nfunction unregisterPath(path) {\n  socket.emit(\"unregisterPath\", path);\n}\n\nexport { getPageData, registerPath, unregisterPath };","map":{"version":3,"sources":["C:/Users/admin/react/Website/web/.cache/socketIo.js"],"names":["io","reportError","clearError","normalizePagePath","socket","inFlightGetPageDataPromiseCache","staticQueryData","pageQueryData","getStaticQueryData","getPageQueryData","socketIo","process","env","NODE_ENV","transports","GATSBY_SOCKET_IO_DEFAULT_TRANSPORT","on","opts","didDataChange","msg","queryData","id","type","payload","JSON","stringify","result","Object","keys","forEach","pathname","emit","message","___emitter","console","warn","err","error","getPageData","Promise","resolve","onPageDataCallback","off","registerPath","path","unregisterPath"],"mappings":"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","sourcesContent":["import io from \"socket.io-client\"\nimport { reportError, clearError } from \"./error-overlay-handler\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nlet socket = null\n\nconst inFlightGetPageDataPromiseCache = {}\nlet staticQueryData = {}\nlet pageQueryData = {}\n\nexport const getStaticQueryData = () => staticQueryData\nexport const getPageQueryData = () => pageQueryData\n\nexport default function socketIo() {\n  if (process.env.NODE_ENV !== `production`) {\n    if (!socket) {\n      // Try to initialize web socket if we didn't do it already\n      try {\n        // force websocket as transport\n        socket = io({\n          transports: [process.env.GATSBY_SOCKET_IO_DEFAULT_TRANSPORT],\n        })\n\n        // when websocket fails, we'll try polling\n        socket.on(`reconnect_attempt`, () => {\n          socket.io.opts.transports = [`polling`, `websocket`]\n        })\n\n        const didDataChange = (msg, queryData) => {\n          const id =\n            msg.type === `staticQueryResult`\n              ? msg.payload.id\n              : normalizePagePath(msg.payload.id)\n          return (\n            !(id in queryData) ||\n            JSON.stringify(msg.payload.result) !== JSON.stringify(queryData[id])\n          )\n        }\n\n        socket.on(`connect`, () => {\n          // we might have disconnected so we loop over the page-data requests in flight\n          // so we can get the data again\n          Object.keys(inFlightGetPageDataPromiseCache).forEach(pathname => {\n            socket.emit(`getDataForPath`, pathname)\n          })\n        })\n\n        socket.on(`message`, msg => {\n          if (msg.type === `staticQueryResult`) {\n            if (didDataChange(msg, staticQueryData)) {\n              staticQueryData = {\n                ...staticQueryData,\n                [msg.payload.id]: msg.payload.result,\n              }\n            }\n          } else if (msg.type === `pageQueryResult`) {\n            if (didDataChange(msg, pageQueryData)) {\n              pageQueryData = {\n                ...pageQueryData,\n                [normalizePagePath(msg.payload.id)]: msg.payload.result,\n              }\n            }\n          } else if (msg.type === `overlayError`) {\n            if (msg.payload.message) {\n              reportError(msg.payload.id, msg.payload.message)\n            } else {\n              clearError(msg.payload.id)\n            }\n          }\n\n          if (msg.type && msg.payload) {\n            ___emitter.emit(msg.type, msg.payload)\n          }\n        })\n\n        // Prevents certain browsers spamming XHR 'ERR_CONNECTION_REFUSED'\n        // errors within the console, such as when exiting the develop process.\n        socket.on(`disconnect`, () => {\n          console.warn(`[socket.io] Disconnected from dev server.`)\n        })\n      } catch (err) {\n        console.error(`Could not connect to socket.io on dev server.`)\n      }\n    }\n    return socket\n  } else {\n    return null\n  }\n}\n\nfunction getPageData(pathname) {\n  pathname = normalizePagePath(pathname)\n  if (inFlightGetPageDataPromiseCache[pathname]) {\n    return inFlightGetPageDataPromiseCache[pathname]\n  } else {\n    inFlightGetPageDataPromiseCache[pathname] = new Promise(resolve => {\n      if (pageQueryData[pathname]) {\n        delete inFlightGetPageDataPromiseCache[pathname]\n        resolve(pageQueryData[pathname])\n      } else {\n        const onPageDataCallback = msg => {\n          if (\n            msg.type === `pageQueryResult` &&\n            normalizePagePath(msg.payload.id) === pathname\n          ) {\n            socket.off(`message`, onPageDataCallback)\n            delete inFlightGetPageDataPromiseCache[pathname]\n            resolve(pageQueryData[pathname])\n          }\n        }\n        socket.on(`message`, onPageDataCallback)\n\n        socket.emit(`getDataForPath`, pathname)\n      }\n    })\n  }\n  return inFlightGetPageDataPromiseCache[pathname]\n}\n\n// Tell websocket-manager.js the new path we're on.\n// This will help the backend prioritize queries for this\n// path.\nfunction registerPath(path) {\n  socket.emit(`registerPath`, path)\n}\n\n// Unregister the former path\nfunction unregisterPath(path) {\n  socket.emit(`unregisterPath`, path)\n}\n\nexport { getPageData, registerPath, unregisterPath }\n"]},"metadata":{},"sourceType":"module"}