{"ast":null,"code":"import{pick}from\"@reach/router/lib/utils\";import stripPrefix from\"./strip-prefix\";import normalizePagePath from\"./normalize-page-path\";var pathCache=new Map();var matchPaths=[];var trimPathname=function trimPathname(rawPathname){var pathname=decodeURIComponent(rawPathname);var trimmedPathname=stripPrefix(pathname,__BASE_PATH__).split(\"#\")[0].split(\"?\")[0];return trimmedPathname;};function absolutify(path){if(path.startsWith(\"/\")||path.startsWith(\"https://\")||path.startsWith(\"http://\")){return path;}return new URL(path,window.location.href+(window.location.href.endsWith(\"/\")?\"\":\"/\")).pathname;}export var setMatchPaths=function setMatchPaths(value){matchPaths=value;};export var findMatchPath=function findMatchPath(rawPathname){var trimmedPathname=cleanPath(rawPathname);var pickPaths=matchPaths.map(function(_ref){var path=_ref.path,matchPath=_ref.matchPath;return{path:matchPath,originalPath:path};});var path=pick(pickPaths,trimmedPathname);if(path){return normalizePagePath(path.route.originalPath);}return null;};export var grabMatchParams=function grabMatchParams(rawPathname){var trimmedPathname=cleanPath(rawPathname);var pickPaths=matchPaths.map(function(_ref2){var path=_ref2.path,matchPath=_ref2.matchPath;return{path:matchPath,originalPath:path};});var path=pick(pickPaths,trimmedPathname);if(path){return path.params;}return{};};export var findPath=function findPath(rawPathname){var trimmedPathname=trimPathname(absolutify(rawPathname));if(pathCache.has(trimmedPathname)){return pathCache.get(trimmedPathname);}var foundPath=findMatchPath(trimmedPathname);if(!foundPath){foundPath=cleanPath(rawPathname);}pathCache.set(trimmedPathname,foundPath);return foundPath;};export var cleanPath=function cleanPath(rawPathname){var trimmedPathname=trimPathname(absolutify(rawPathname));var foundPath=trimmedPathname;if(foundPath===\"/index.html\"){foundPath=\"/\";}foundPath=normalizePagePath(foundPath);return foundPath;};","map":{"version":3,"sources":["C:/Users/admin/react/Website/web/.cache/find-path.js"],"names":["pick","stripPrefix","normalizePagePath","pathCache","Map","matchPaths","trimPathname","rawPathname","pathname","decodeURIComponent","trimmedPathname","__BASE_PATH__","split","absolutify","path","startsWith","URL","window","location","href","endsWith","setMatchPaths","value","findMatchPath","cleanPath","pickPaths","map","matchPath","originalPath","route","grabMatchParams","params","findPath","has","get","foundPath","set"],"mappings":"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","sourcesContent":["import { pick } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\nfunction absolutify(path) {\n  // If it's already absolute, return as-is\n  if (\n    path.startsWith(`/`) ||\n    path.startsWith(`https://`) ||\n    path.startsWith(`http://`)\n  ) {\n    return path\n  }\n  // Calculate path relative to current location, adding a trailing slash to\n  // match behavior of @reach/router\n  return new URL(\n    path,\n    window.location.href + (window.location.href.endsWith(`/`) ? `` : `/`)\n  ).pathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  const pickPaths = matchPaths.map(({ path, matchPath }) => {\n    return {\n      path: matchPath,\n      originalPath: path,\n    }\n  })\n\n  const path = pick(pickPaths, trimmedPathname)\n\n  if (path) {\n    return normalizePagePath(path.route.originalPath)\n  }\n\n  return null\n}\n\n/**\n * Return a matchpath params from reach/router rules\n * if `match-paths.json` contains `{ \":bar/*foo\" }`, and the path is /baz/zaz/zoo\n * then it returns\n *  { bar: baz, foo: zaz/zoo }\n *\n * @param {string} rawPathname A raw pathname\n * @return {object}\n */\nexport const grabMatchParams = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  const pickPaths = matchPaths.map(({ path, matchPath }) => {\n    return {\n      path: matchPath,\n      originalPath: path,\n    }\n  })\n\n  const path = pick(pickPaths, trimmedPathname)\n\n  if (path) {\n    return path.params\n  }\n\n  return {}\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(absolutify(rawPathname))\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(absolutify(rawPathname))\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n"]},"metadata":{},"sourceType":"module"}